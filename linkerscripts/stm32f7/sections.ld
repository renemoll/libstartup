
ENTRY(ResetHandler)
OUTPUT_ARCH(arm)
OUTPUT_FORMAT(elf32-littlearm)

/*
 * Heap and stack size to verify if all fits into RAM.
 */
__heap_size__ = 0x100;
__stack_size__ = 0x100;

SECTIONS
{
	/*
	 * Code and some special (helper) sections.
	 */
	.text : ALIGN(4)
	{
		FILL(0xFF);

		/* Interrupt vectors */
		__vectors_start__ = ABSOLUTE(.);
		KEEP(*(.isr_vector))
		KEEP(*(.isr_vector.*))

		/* Generic code */
		*(.text)
		*(.text.*)

		/*
		 * Stub sections generated by the linker, to glue together 
		 * ARM and Thumb code. .glue_7 is used for ARM code calling 
		 * Thumb code, and .glue_7t is used for Thumb code calling 
		 * ARM code.
		 */
		*(.glue_7)
		*(.glue_7t)

		/*
		 * Exception handling frame, used to unwind the stack.
		 */
		*(.eh_frame)
	} >FLASH

	/*
	 * Constant (read-only) data.
	 */
	.rodata : ALIGN(4)
	{
		/* Read only data (constants, strings, etc.) */
		*(.rodata)
		*(.rodata*)

		/* Initialization/termination code */
		. = ALIGN(4);
		KEEP (*(.init))
		. = ALIGN(4);
		KEEP (*(.fini))

		/*
		 * The init/preinit arrays, i.e. an array of pointers to initialization 
		 * functions/constructors.
		 */
		. = ALIGN(4);
		__preinit_array_start__ = .;
		KEEP (*(.preinit_array))
		KEEP (*(.preinit_array.*))
		__preinit_array_end__ = .;

		. = ALIGN(4);
		__init_array_start__ = .;
		KEEP (*(SORT(.init_array.*)))
		KEEP (*(.init_array*))
		__init_array_end__ = .;

		. = ALIGN(4);
		__fini_array_start__ = .;
		KEEP (*(SORT(.fini_array.*)))
		KEEP (*(.fini_array*))
		__fini_array_end__ = .;
	} >FLASH

	/*
	 * ARM sections:
	 * - .ARM.extab: exception unwinding information
	 * - .ARM.exidx: index entries for section unwinding
	 */
	.ARM.extab : ALIGN(4)
	{
		*(.ARM.extab*)
		*(.gnu.linkonce.armextab.*) 
	} >FLASH

	.ARM : ALIGN(4)
	{
		__exidx_start = .;
		*(.ARM.exidx*)
		*(.gnu.linkonce.armexidx.*)
		__exidx_end = .;
	} >FLASH

	/*
	 * Initialized variables, which are not read-only, are stored in FLASH
	 * and copied into RAM as part of the startup code.
	 */
	.data : ALIGN(4)
	{
		. = ALIGN(4);
		__data_dest_start__ = .;

		*(.data)
		*(.data*)

		. = ALIGN(4);
		__data_dest_end__ = .;
	} >DTCMRAM AT> FLASH
	__data_src__ = LOADADDR(.data);

	/*
	 * Embedded the GNU build ID into the resulting file.
	 */
	.gnu_build_id :
	{
		PROVIDE(g_note_build_id = .);
		*(.note.gnu.build-id)
	} > FLASH

	/*
	 * Uninitialized data, not read-only, filled with a default value
	 * defined in the startup code.
	 */
	.bss (NOLOAD) : ALIGN(4)
	{
		. = ALIGN(4);
		__bss_start__ = .;

		*(.bss)
		*(.bss*)

		. = ALIGN(4);
		__bss_end__ = .;
	} >DTCMRAM

	._user_heap (NOLOAD) : ALIGN(8)
	{
		. = ALIGN(8);
		__heap_start__ = .;

		. = . + __heap_size__;

		. = ALIGN(8);
		__heap_end__ = .;
	} >DTCMRAM

	/*
	 * Stack and heap sections to verify that there is enough RAM left available.
	 */
	._user_stack (NOLOAD) : ALIGN(8)
	{
		. = ALIGN(8);
		__stack_start__ = .;

		. = . + __stack_size__;

		. = ALIGN(8);
		__stack_end__ = .;
	} >DTCMRAM
	__stack_top__ = LOADADDR(._user_stack) + __stack_size__;

	/*
	 * Remove debug information from the standard libraries.
	 */
	/DISCARD/ :
	{
		libc.a(*)
		libm.a(*)
		libgcc.a(*)
	}
}

/*
 * Compatability
 * 
 */

PROVIDE(ResetHandler = Reset_Handler);

_estack = __stack_top__;
_sidata = __data_src__;
_sdata = __data_dest_start__;
_edata = __data_dest_end__;
_sbss = __bss_start__;
_ebss = __bss_end__;
